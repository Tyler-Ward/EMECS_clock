#define FILE_REVISION "REV 0042"


/*
$Id:$

ST7565 LCD library!

Copyright (C) 2010 Limor Fried, Adafruit Industries

This library is free software; you can redistribute it and/or
modify it under the terms of the GNU Lesser General Public
License as published by the Free Software Foundation; either
version 2.1 of the License, or (at your option) any later version.

This library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public
License along with this library; if not, write to the Free Software
Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA

 // some of this code was written by <cstone@pobox.com> originally; it is in the public domain.
*/

#include <avr/io.h>
#include <avr/interrupt.h>

#define F_CPU 8000000UL
#include <util/delay.h>
#include <util/twi.h>
#include <stdlib.h>
#include <string.h>
#include "stlcd.h"
#include "glcd.h"
#include "util.h"
//#include "icon.h"


#define BLA_DDR DDRB
#define BLA_PIN PINB
#define BLA_PORT PORTB
#define BLA 2

#define SID_DDR DDRB
#define SID_PIN PINB
#define SID_PORT PORTB
#define SID 1

#define SCLK_DDR DDRB
#define SCLK_PIN PINB
#define SCLK_PORT PORTB
#define SCLK 0

#define A0_DDR DDRD
#define A0_PIN PIND
#define A0_PORT PORTD
#define A0 7

#define RST_DDR DDRD
#define RST_PIN PIND
#define RST_PORT PORTD
#define RST 6

#define CS_DDR DDRD
#define CS_PIN PIND
#define CS_PORT PORTD
#define CS 5

#define LED_DDR DDRD
#define LED_PORT PORTD
#define LED 2

#define I2C_ADDR 0x1E
#define TWSR_MASK 0xF8

uint8_t is_reversed = 0;

int pagemap[] = { 3, 2, 1, 0, 7, 6, 5, 4 };

uint8_t twi_interrupt_count = 0;

uint8_t buffer[128*64/8] = {
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x01,0x01,0x00,0x00,0x00,0x00,0x01,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x01,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x01,
    0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

    0x00,0x00,0x00,0xFF,0xFF,0x00,0x00,0x00,0x00,0x03,0x03,0x06,0x06,0x06,0x06,0x03,
    0xFF,0xFF,0x00,0x00,0x00,0x00,0xFF,0xFF,0x00,0x00,0x00,0x00,0x01,0x03,0x06,0x06,
    0x06,0x06,0x07,0x03,0x00,0x00,0x00,0x00,0xFF,0xFF,0x01,0x01,0x01,0x01,0x01,0x01,
    0x01,0x01,0xFF,0xFF,0x00,0x00,0x00,0x00,0x06,0x06,0x06,0x06,0x06,0x07,0x03,0x01,
    0x00,0x00,0x00,0x00,0x07,0x07,0x03,0x06,0x06,0x06,0x07,0x03,0x01,0x00,0x00,0x00,
    0x00,0x03,0x03,0x06,0x06,0x06,0x06,0x03,0xFF,0xFF,0x00,0x00,0x00,0x01,0x03,0x06,
    0x06,0x06,0x06,0x06,0x06,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xC3,0xE2,0xE2,
    0xE3,0x01,0x01,0x01,0x01,0xE3,0xE2,0xE2,0xC3,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

    0x00,0x00,0x00,0xFF,0xFF,0x00,0x00,0x00,0xF8,0xFE,0x06,0x03,0x03,0x03,0x03,0x06,
    0xFF,0xFF,0x00,0x00,0x00,0x00,0xFF,0xFF,0x00,0x00,0x00,0xF8,0xFE,0x66,0x63,0x63,
    0x63,0x63,0x63,0xE3,0xE0,0x00,0x00,0x00,0xFF,0xFF,0x80,0x80,0x80,0x80,0x80,0x80,
    0x80,0x80,0xFF,0xFF,0x00,0x00,0x00,0x1C,0x3E,0x63,0x63,0x63,0x63,0x66,0xFF,0xFF,
    0x00,0x00,0x00,0x00,0xFF,0xFF,0x00,0x00,0x00,0x00,0x00,0xFF,0xFF,0x00,0x00,0x00,
    0xF8,0xFE,0x06,0x03,0x03,0x03,0x03,0x06,0xFF,0xFF,0x00,0x00,0x00,0xC3,0xE3,0x63,
    0x63,0x23,0x33,0x3E,0x1C,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x40,
    0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

    0x00,0x00,0x00,0x01,0x03,0x03,0x06,0x06,0x06,0x06,0x06,0x06,0x02,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x01,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x03,0x03,0x07,0x06,0x06,0x06,0x06,0x06,0x06,
    0x00,0x00,0x00,0x0F,0x0F,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x0F,0x0F,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

    0x00,0x00,0x00,0xF0,0xF8,0x18,0x18,0x0C,0x0C,0x0C,0x06,0x07,0x03,0x00,0x00,0x00,
    0x3F,0x3F,0x18,0x30,0x30,0x30,0x38,0x1F,0x0F,0x18,0x30,0x30,0x30,0x38,0x1F,0x0F,
    0x00,0x00,0x00,0x00,0x31,0x33,0x33,0x33,0x33,0x3B,0x1F,0x0F,0x00,0x00,0x00,0x00,
    0x3F,0x3F,0x18,0x18,0x30,0x30,0x30,0x30,0xFF,0xFF,0x30,0x30,0x30,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x3F,0xFF,0xC0,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0xFF,0xFF,0x00,0x00,0x00,0x07,0x0F,0x1C,0x38,0x30,0x30,0x30,0x38,
    0x1C,0x1F,0x07,0x00,0x00,0x07,0x0F,0x1C,0x38,0x30,0x30,0x30,0x30,0x00,0x00,0x00,
    0x00,0xFF,0xFF,0x03,0x03,0x07,0x0C,0x18,0x30,0x20,0x00,0x00,0x00,0x00,0x00,0x00,

    0x00,0x00,0x00,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x30,0xF0,0xE0,0x00,0x00,0x00,
    0xF8,0xF8,0x00,0x00,0x00,0x00,0x00,0xF8,0xF8,0x00,0x00,0x00,0x00,0x00,0xF8,0xF8,
    0x00,0x00,0x00,0xE0,0xF0,0x18,0x18,0x18,0x18,0x30,0xF8,0xF8,0x00,0x00,0x00,0x00,
    0xF8,0xF8,0x00,0x00,0x00,0x00,0x00,0x00,0xF0,0xF8,0x18,0x18,0x18,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0xC0,0xE0,0x70,0x30,0x18,0x18,0x18,0x18,0x18,0x18,0x18,
    0x00,0x00,0x00,0xF8,0xF8,0x00,0x00,0x00,0xC0,0xF0,0x70,0x38,0x18,0x18,0x18,0x38,
    0x70,0xE0,0xC0,0x00,0x00,0xC0,0xF0,0x70,0x38,0x18,0x18,0x18,0x18,0x10,0x00,0x00,
    0x00,0xF8,0xF8,0x00,0x80,0xC0,0xE0,0x30,0x18,0x08,0x00,0x00,0x00,0x00,0x00,0x00,

    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
};

#define MAX_INSTRUCTION_LENGTH 30
uint8_t instruction_buffer[MAX_INSTRUCTION_LENGTH + 1];
uint8_t inst_buff_position = 0;

extern const uint8_t PROGMEM font[];

int main(void){
    setup();
	setup_i2c();

#ifdef DEBUG
	uint8_t debug_msg[22] = "Debug Mode Enabled.";
	drawstring(buffer,0,0,debug_msg);
	write_buffer(buffer);
	_delay_ms(1000);
	clear_screen();
	clear_buffer(buffer);
#endif	
		
	display_time(0,0,0,0);	
	display_date(0,0,1,0);
	drawstring(buffer,0,6,"Next Lecture:");
	drawstring(buffer,0,7,"COMP3006: Real Time");		
	write_buffer(buffer);			
			
    while (1) {
        loop();
    }
}

void display_time(uint8_t hour_msB, uint8_t hour_lsB, uint8_t minute_msB, uint8_t minute_lsB){
	
	drawbigchar(buffer, ((128/2)-(18*2+4)),2,hour_msB+'0');
	drawbigchar(buffer, ((128/2)-(19+4)),2,hour_lsB+'0');
	drawbigchar(buffer, ((128/2)-(8)),2,':');
	drawbigchar(buffer, ((128/2)+(3+4)),2,minute_msB+'0');
	drawbigchar(buffer, ((128/2)+(21+3)),2,minute_lsB+'0');
	drawline(buffer, 0, 46, 128, 46, 1);
	write_buffer(buffer);
	
}

void display_date(uint8_t weekday, uint8_t day_MSD, uint8_t day_LSD, uint8_t month){
	uint8_t months[12][4] = {"Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"};
	uint8_t weekdays[7][4] = {"Sun","Mon","Tue","Wed","Thu","Fri","Sat"};
	uint8_t date_offset = 34; // Pixels
		
		
	drawstring(buffer,0+date_offset,0,weekdays[weekday]);
	drawchar(buffer,24+date_offset,0,day_MSD+'0');
	drawchar(buffer,30+date_offset,0,day_LSD+'0');
	drawstring(buffer,42+date_offset,0,months[month]);	
	write_buffer(buffer);
}

void marqueestring(uint8_t *buff, uint8_t line, uint8_t *c){
	uint8_t length = strlen(c);
	for(uint8_t i = 0; i <= 128; i+=6){
		for(uint8_t x = 128-i; (x < 128) && (x<(128-i+(length*6)+6)); x++){
			if((((x+i)-128)%6)==5){
				buff[x + (line*128) ] = 0x00;
				continue;
			}
			else if(x>=(128-i+(length*6))){
				buff[x + (line*128) ] = pgm_read_byte(font+(' '*5));
				continue;
			}
			buff[x + (line*128) ] = pgm_read_byte(font+(c[(((x+i)-128)/6)]*5)+(((x+i)-128)%6));	
		}
		write_buffer(buffer);
		_delay_ms(250);
	}
}

void execute_instruction(void){
	uint8_t error_msg[22] = "Err: Bad GPU Code.";
	uint8_t code_string[22];
	switch(instruction_buffer[0]){
		case GPU_PRINT_STRING:
			drawstring(buffer,instruction_buffer[1],instruction_buffer[2],&(instruction_buffer[3]));
			write_buffer(buffer);
			break;
		case GPU_SET_PIXEL:
			setpixel(buffer,instruction_buffer[1],instruction_buffer[2],1);
			write_buffer(buffer);
			break;
		case GPU_CLEAR_PIXEL:
			setpixel(buffer,instruction_buffer[1],instruction_buffer[2],0);
			write_buffer(buffer);
			break;
		case GPU_DRAW_LINE:
			drawline(buffer,instruction_buffer[1],instruction_buffer[2],instruction_buffer[3],instruction_buffer[4],instruction_buffer[5]);
			write_buffer(buffer);
			break;
		case GPU_DRAW_RECTANGLE:
			drawrect(buffer,instruction_buffer[1],instruction_buffer[2],instruction_buffer[3],instruction_buffer[4],instruction_buffer[5]);
			write_buffer(buffer);
			break;
		case GPU_FILL_RECTANGLE:
			fillrect(buffer,instruction_buffer[1],instruction_buffer[2],instruction_buffer[3],instruction_buffer[4],instruction_buffer[5]);
			write_buffer(buffer);
			break;
		case GPU_DRAW_CIRCLE:
			drawcircle(buffer,instruction_buffer[1],instruction_buffer[2],instruction_buffer[3],instruction_buffer[4]);
			write_buffer(buffer);
			break;
		case GPU_CLEAR_SCREEN:
			clear_screen();
			break;
		case GPU_SET_TIME:
			display_time(instruction_buffer[1],instruction_buffer[2],instruction_buffer[3],instruction_buffer[4]);
			break;
		case GPU_SET_DATE:
			display_date(instruction_buffer[1],instruction_buffer[2],instruction_buffer[3],instruction_buffer[4]);
			break;
			
		default:
#ifdef DEBUG
			clear_screen();
			drawstring(buffer,0,0,error_msg);
			code_string[0] = (instruction_buffer[0] & 0x80) ? '1' : '0';
			code_string[1] = (instruction_buffer[0] & 0x40) ? '1' : '0';
			code_string[2] = (instruction_buffer[0] & 0x20) ? '1' : '0';
			code_string[3] = (instruction_buffer[0] & 0x10) ? '1' : '0';
			code_string[4] = (instruction_buffer[0] & 0x08) ? '1' : '0';
			code_string[5] = (instruction_buffer[0] & 0x04) ? '1' : '0';
			code_string[6] = (instruction_buffer[0] & 0x02) ? '1' : '0';
			code_string[7] = (instruction_buffer[0] & 0x01) ? '1' : '0';
			code_string[8] = '\0';
			drawstring(buffer,0,1,code_string);
			write_buffer(buffer);
#endif
			break;
	}	
	
}

ISR(TWI_vect){
	cli();
	uint8_t errord = 0;
	
	uint8_t status_reg = TWSR & TWSR_MASK;
	uint8_t data_reg;
	if (status_reg == TW_SR_DATA_ACK){
		data_reg = TWDR;
	}
	else{
		data_reg = 0xAA;
	}
	
#ifdef DEBUG
	// Set status messages:
	uint8_t my_string[22] = "I2C Interrupt Fired";
	uint8_t status_string[22];
	uint8_t data_string[22];
	
	
	// Write interrupt msg
	drawstring(buffer,0,0,my_string);
#endif
	
	// If the I2C master is asking to read:
	switch(status_reg){
		case TW_ST_SLA_ACK:
#ifdef DEBUG
			strcpy(status_string,"Err: TW_ST_SLA_ACK");
			// Write status and data strings.
			drawstring(buffer,0,1,status_string);
#endif
			break;
			
		case TW_SR_SLA_ACK:
		case TW_SR_GCALL_ACK:
#ifdef DEBUG
			strcpy(status_string,"TW_SR_SLA_ACK");
			// Write status and data strings.
			drawstring(buffer,0,1,status_string);
#endif
			inst_buff_position = 0;
			break;
			
		case TW_SR_DATA_ACK:
		case TW_SR_GCALL_DATA_ACK:
#ifdef DEBUG
			strcpy(status_string,"TW_SR_DATA_ACK");
			data_string[0] = (data_reg) ? '1' : '0';
			data_string[1] = (data_reg) ? '1' : '0';
			data_string[2] = (data_reg) ? '1' : '0';
			data_string[3] = (data_reg) ? '1' : '0';
			data_string[4] = (data_reg) ? '1' : '0';
			data_string[5] = (data_reg) ? '1' : '0';
			data_string[6] = (data_reg) ? '1' : '0';
			data_string[7] = (data_reg) ? '1' : '0';
			data_string[8] = '\0';
			drawstring(buffer,0,3,data_string);
			// Write status and data strings.
			drawstring(buffer,0,2,status_string);
#endif
			instruction_buffer[inst_buff_position] = data_reg;
			inst_buff_position++;
			break;
		case TW_SR_STOP:
#ifdef DEBUG
			strcpy(status_string,"TW_SR_STOP");
			// This is where we ought to trigger execution.
			// // // TODO
			drawstring(buffer,0,4,status_string);
#endif
			instruction_buffer[inst_buff_position] = '\0';
			inst_buff_position++;
			execute_instruction();
			break;
		default:
#ifdef DEBUG
			strcpy(status_string,"I2C Unknown Status");
			drawstring(buffer,0,5,status_string);
			
			data_string[0] = (status_reg & 0x80) ? '1' : '0';
			data_string[1] = (status_reg & 0x40) ? '1' : '0';
			data_string[2] = (status_reg & 0x20) ? '1' : '0';
			data_string[3] = (status_reg & 0x10) ? '1' : '0';
			data_string[4] = (status_reg & 0x08) ? '1' : '0';
			data_string[5] = (status_reg & 0x04) ? '1' : '0';
			data_string[6] = (status_reg & 0x02) ? '1' : '0';
			data_string[7] = (status_reg & 0x01) ? '1' : '0';
			data_string[8] = '\0';
			drawstring(buffer,0,6,data_string);
#endif
			break;
	}
	
	// Increment counter
	twi_interrupt_count += 1;
	
	// Write to display.
	write_buffer(buffer);
	

	// Finally, set TWINT
	TWCR |= (1<<TWINT);
	sei();
}

void setup_i2c(void){
	TWAR = I2C_ADDR;
	TWAR |= 0x01; // Enable global call
	TWCR = (1<<TWEA)|(1<<TWEN)|(1<<TWIE);
	sei();
}


void loop(void) {}

void setup(void) {
    uart_init(BRRL_192);
    st7565_init();
    st7565_command(CMD_DISPLAY_ON);
    st7565_command(CMD_SET_ALLPTS_NORMAL);
    st7565_set_brightness(0x32);
    clear_screen();

	uint8_t revision_str[22] = FILE_REVISION;
	drawstring(buffer,0,7,revision_str);
    write_buffer(buffer);
    _delay_ms(2000);
    clear_buffer(buffer);
    write_buffer(buffer);
}

/* 

CODE PAST THIS POINT IS NOT WRITTEN BY THE ENTRANTS TO THE EMECS COMPETITION

*/

void clear_screen(void) {
  uint8_t p, c;
  
  for(p = 0; p < 8; p++) {
    /*
      putstring("new page! ");
      uart_putw_dec(p);
      putstring_nl("");
    */

    st7565_command(CMD_SET_PAGE | p);
    for(c = 0; c < 129; c++) {
      //uart_putw_dec(c);
      //uart_putchar(' ');
      st7565_command(CMD_SET_COLUMN_LOWER | (c & 0xf));
      st7565_command(CMD_SET_COLUMN_UPPER | ((c >> 4) & 0xf));
      st7565_data(0x0);
    }     
  }
}


void st7565_init(void) {
  // set pin directions
  SID_DDR |= _BV(SID);
  SCLK_DDR |= _BV(SCLK);
  A0_DDR |= _BV(A0);
  RST_DDR |= _BV(RST);
  CS_DDR |= _BV(CS);
  
  // toggle RST low to reset; CS low so it'll listen to us
  CS_PORT &= ~_BV(CS);
  RST_PORT &= ~_BV(RST);
  _delay_ms(500);
  RST_PORT |= _BV(RST);

  // LCD bias select
  st7565_command(CMD_SET_BIAS_7);
  // ADC select
  st7565_command(CMD_SET_ADC_NORMAL);
  // SHL select
  st7565_command(CMD_SET_COM_NORMAL);
  // Initial display line
  st7565_command(CMD_SET_DISP_START_LINE);

  // turn on voltage converter (VC=1, VR=0, VF=0)
  st7565_command(CMD_SET_POWER_CONTROL | 0x4);
  // wait for 50% rising
  _delay_ms(50);

  // turn on voltage regulator (VC=1, VR=1, VF=0)
  st7565_command(CMD_SET_POWER_CONTROL | 0x6);
  // wait >=50ms
  _delay_ms(50);

  // turn on voltage follower (VC=1, VR=1, VF=1)
  st7565_command(CMD_SET_POWER_CONTROL | 0x7);
  // wait
  _delay_ms(10);

  // set lcd operating voltage (regulator resistor, ref voltage resistor)
  st7565_command(CMD_SET_RESISTOR_RATIO | 0x6);

  // initial display line
  // set page address
  // set column address
  // write display data
}

inline void spiwrite(uint8_t c) {
  int8_t i;
  for (i=7; i>=0; i--) {
    SCLK_PORT &= ~_BV(SCLK);
    if (c & _BV(i))
      SID_PORT |= _BV(SID);
    else
      SID_PORT &= ~_BV(SID);
    SCLK_PORT |= _BV(SCLK);
  }
}

void st7565_command(uint8_t c) {
  A0_PORT &= ~_BV(A0);

  spiwrite(c);
}

void st7565_data(uint8_t c) {
  A0_PORT |= _BV(A0);

  spiwrite(c);
}
void st7565_set_brightness(uint8_t val) {
    st7565_command(CMD_SET_VOLUME_FIRST);
    st7565_command(CMD_SET_VOLUME_SECOND | (val & 0x1f));
}


void write_buffer(uint8_t *buffer) {
  uint8_t c, p;

  for(p = 0; p < 8; p++) {
    /*
      putstring("new page! ");
      uart_putw_dec(p);
      putstring_nl("");
    */

    st7565_command(CMD_SET_PAGE | pagemap[p]);
    st7565_command(CMD_SET_COLUMN_LOWER | (0x0 & 0xf));
    st7565_command(CMD_SET_COLUMN_UPPER | ((0x0 >> 4) & 0xf));
    st7565_command(CMD_RMW);
    st7565_data(0xff);
    
    //st7565_data(0x80);
    //continue;
    
    for(c = 0; c < 128; c++) {
      //uart_putw_dec(c);
      //uart_putchar(' ');
      st7565_data(buffer[(128*p)+c]);
    }
  }
}

